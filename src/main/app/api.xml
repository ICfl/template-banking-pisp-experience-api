<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:validation="http://www.mulesoft.org/schema/mule/validation" 
	xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking" 
	xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting"
	xmlns:dw="http://www.mulesoft.org/schema/mule/ee/dw" 
	xmlns="http://www.mulesoft.org/schema/mule/core" 
	xmlns:apikit="http://www.mulesoft.org/schema/mule/apikit" 
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" 
	xmlns:http="http://www.mulesoft.org/schema/mule/http" 
	xmlns:spring="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/apikit http://www.mulesoft.org/schema/mule/apikit/current/mule-apikit.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
http://www.mulesoft.org/schema/mule/ee/dw http://www.mulesoft.org/schema/mule/ee/dw/current/dw.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/validation http://www.mulesoft.org/schema/mule/validation/current/mule-validation.xsd">
    <http:request-config name="checking-account-system-api" protocol="HTTPS" host="mocksvc.mulesoft.com" port="443" basePath="/mocks/5b0f1bed-d787-4bbe-ab59-34de20bf5b1b/api" doc:name="HTTP Request Configuration">
        <http:raml-api-configuration location="account-system-api/api.raml"/>
    </http:request-config>
    
    <flow name="get:/initiate:api-config">
        <validation:all doc:name="validate query params">
            <validation:validations>
                <validation:is-true expression="#[message.inboundProperties.'http.query.params'.redirect_uri.startsWith(&quot;https&quot;)]" message="Redirect URI must be using HTTPS"/>
                <validation:is-url url="#[message.inboundProperties.'http.query.params'.redirect_uri]" message="Redirect URI must be valid URL"/>
            </validation:validations>
        </validation:all>
        <logger message="#[message.inboundProperties.'http.query.string' ]" level="INFO" doc:name="Log path"/>
        <set-property propertyName="Location" value="#[  '${as.authorize_url}?' + message.inboundProperties.'http.query.string' ]" doc:name="Location"/>
        <set-property propertyName="http.status" value="302" doc:name="http.status"/>
        <set-payload value="#[NullPayload.getInstance()]" doc:name="Set Null Payload"/>
    </flow>
    
    <flow name="get:/authorize">
        <http:listener config-ref="http-continuation" path="/api/oauth2/authorize" doc:name="localhost:8082/api/payment/authorize" allowedMethods="GET"/>
        <set-variable variableName="jwtPaymentToken" value="#[message.inboundProperties.'http.query.params'.request]" doc:name="set var jwtPaymentToken"/>
        <flow-ref name="validate-jwt-token" doc:name="validate-jwt-token"/>
        <logger message="JWT token is valid" level="INFO" doc:name="log VALID JWT token"/>
        <parse-template location="html\login.html" doc:name="login form"/>
    </flow>
    <sub-flow name="validate-client-id">
        <set-variable variableName="validClient" value="#[message.inboundProperties.'http.query.params'.client_id == ${merchant.client_id}]" doc:name="var validClient"/>
    </sub-flow>
    
    <sub-flow name="validate-jwt-token">
        <scripting:transformer returnClass="java.lang.String" doc:name="groovy validation script">
            <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.keys.HmacKey;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;
import java.security.Key;

String clientSecret = '${merchant.client_secret}';
String expectedAudience = '${pisp.expected_audience}';

Key key = new HmacKey(clientSecret.getBytes("UTF-8"));

JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedAudience(expectedAudience)
			.setVerificationKey(key)
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(flowVars.jwtPaymentToken);
return jwtClaims.toJson();]]></scripting:script>
        </scripting:transformer>
        <logger message="Claims: #[payload]" level="INFO" doc:name="log claims"/>
        <set-variable variableName="isTokenValid " value="#[true]" doc:name="set &quot;isTokenValid&quot; variable"/>
    </sub-flow>
    
    <flow name="post:/authorize">
        <http:listener config-ref="http-continuation" path="api/oauth2/authorize" doc:name="localhost:8082/api/oauth2/authorize" allowedMethods="POST"/>
        <logger message="#[message.inboundProperties.'http.query.string']" level="INFO" doc:name="Logger"/>
        <validation:is-true message="Bank user credentials must be valid" expression="#[payload.uname == '${user.username}' &amp;&amp; payload.pwd == '${user.password}']" doc:name="Validate user credentials"/>
        <enricher source="#[payload]" target="#[flowVars.rsaKeyPairString]" doc:name="var rsaKeyPair">
            <parse-template location="jwk-pair.jwk" doc:name="load RSA keypair"/>
        </enricher>
        <enricher source="#[payload]" target="#[flowVars.encryptionKeyString]" doc:name="var EncryptionKey">
            <parse-template location="shared-key.jwk" doc:name="load AES key"/>
        </enricher>
        <scripting:transformer returnClass="java.lang.String" doc:name="Create access token" >
            <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwe.JsonWebEncryption;
import org.jose4j.jws.JsonWebSignature;
import org.jose4j.jwe.KeyManagementAlgorithmIdentifiers;
import org.jose4j.jwk.JsonWebKey;
import org.jose4j.keys.HmacKey;
import org.jose4j.jwk.RsaJsonWebKey;
import org.jose4j.jwk.OctetSequenceJsonWebKey;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;
import org.apache.commons.io.FileUtils;
import java.security.Key;

JwtClaims claims = new JwtClaims();
claims.setIssuer("https://anypoint-bank.cloudhub.io");  
claims.setExpirationTimeMinutesInTheFuture(5); 
claims.setIssuedAtToNow();  
claims.setNotBeforeMinutesInThePast(0); 
claims.setSubject("${user.user_id}"); 
claims.setClaim("ssn","${user.user_ssn}");


RsaJsonWebKey signingKey = (RsaJsonWebKey) JsonWebKey.Factory.newJwk(flowVars.rsaKeyPairString);

JsonWebSignature jws = new JsonWebSignature();
jws.setAlgorithmHeaderValue('${as.signing.algorithm}');
jws.setKey(signingKey.getPrivateKey());
jws.setPayload(claims.toJson());

String jwsString = jws.getCompactSerialization();

encryptionKey = (OctetSequenceJsonWebKey) JsonWebKey.Factory.newJwk(flowVars.encryptionKeyString)

JsonWebEncryption jwe = new JsonWebEncryption();
jwe.setAlgorithmHeaderValue(KeyManagementAlgorithmIdentifiers.DIRECT);
jwe.setEncryptionMethodHeaderParameter('${as.encryption.algorithm}');
jwe.setContentTypeHeaderValue("JWT");
jwe.setPayload(jwsString);
jwe.setKey(encryptionKey.getKey());
		
return jwe.getCompactSerialization();
]]></scripting:script>
        </scripting:transformer>

        <logger level="INFO" doc:name="redirect to account"/>
        <set-property propertyName="http.status" value="302" doc:name="http.status 302"/>
        <set-property propertyName="Location" value="#['${pisp.confirmation_url}?' + message.inboundProperties.'http.query.string' + '&amp;access_token=' + payload]" doc:name="Location"/>
        <set-payload value="#[NullPayload.getInstance()]" doc:name="Null Payload"/>

        <choice-exception-strategy doc:name="Choice Exception Strategy">
            <catch-exception-strategy when="#[exception.causedBy(org.mule.extension.validation.api.ValidationException)]" doc:name="Redirect to login page">
                <set-property propertyName="http.status" value="302" doc:name="Status 302"/>
                <set-property propertyName="Location" value="#['${as.authorize_url}?' + message.inboundProperties.'http.query.string' ]" doc:name="Location"/>
                <set-payload value="#[NullPayload.getInstance()]" doc:name="Null Payload"/>
            </catch-exception-strategy>
        </choice-exception-strategy>

    </flow>
    
    <sub-flow name="getClientCredentials">
        <dw:transform-message doc:name="mocked credentials">
            <dw:set-payload><![CDATA[%dw 1.0
%output application/java
---
{
	client_id: p('app.client_id'),
	client_secret: p('app.client_secret'),
	redirect_uri: p('app.redirect_uri')
}]]></dw:set-payload>
        </dw:transform-message>
    </sub-flow>
    
    <flow name="get:/account">
        <http:listener config-ref="http-continuation" path="/api/payment/account" allowedMethods="GET" doc:name="localhost:8082/api/payment/account">
         	<http:response-builder>
                <http:header headerName="Content-Type" value="text/html"/>
            </http:response-builder>
         </http:listener>
        <logger message="#[message.inboundProperties.'http.query.string']" level="INFO" doc:name="Log request"/>
        <set-variable variableName="queryString" value="#[message.inboundProperties.'http.query.string']" doc:name="save queryString"/>
        <validation:all doc:name="Validate request">
            <validation:validations>
                <validation:is-not-empty value="#[message.inboundProperties.'http.query.params'.request]" message="request cannot be empty"/>
                <validation:is-not-empty value="#[message.inboundProperties.'http.query.params'.redirect_uri]" message="redirect_uri cannot be empty"/>
                <validation:is-not-empty value="#[message.inboundProperties.'http.query.params'.client_id]" message="client_id cannot be empty"/>
            </validation:validations>
        </validation:all>
        <set-variable variableName="access_token" value="#[message.inboundProperties.'http.query.params'.access_token]" doc:name="access_token"/>
        <set-variable variableName="paymentRequestJWS" value="#[message.inboundProperties.'http.query.params'.request]" doc:name="paymentRequestJWS"/>
        <enricher source="#[payload]" target="#[flowVars.decryptionKeyString]" doc:name="var decryptionKeyString">
            <parse-template location="shared-key.jwk" doc:name="load AES key"/>
        </enricher>
        <logger message="#[payload]" level="INFO" doc:name="validate access_token"/>
        <enricher source="#[payload]" target="#[flowVars.accessTokenClaims]" doc:name="var accessTokenClaims">
            <scripting:transformer returnClass="java.lang.String" doc:name="Validate access_token">
                <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.keys.HmacKey;
import org.jose4j.keys.resolvers.HttpsJwksVerificationKeyResolver;
import org.jose4j.jwk.HttpsJwks;
import org.jose4j.jwk.JsonWebKey;
import org.jose4j.jwk.OctetSequenceJsonWebKey;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;
import org.jose4j.jwa.AlgorithmConstraints;
import org.jose4j.jwa.AlgorithmConstraints.ConstraintType;
import java.security.Key;

decryptionKey = (OctetSequenceJsonWebKey) JsonWebKey.Factory.newJwk(flowVars.decryptionKeyString);

HttpsJwksVerificationKeyResolver verificationKeys = new HttpsJwksVerificationKeyResolver(new HttpsJwks('${as.jwks.url}'));
    
JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setJwsAlgorithmConstraints(new AlgorithmConstraints(ConstraintType.WHITELIST, "RS512"))
			.setJweAlgorithmConstraints(new AlgorithmConstraints(ConstraintType.WHITELIST, "dir"))
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedIssuer('${as.issuer}')
			.setVerificationKeyResolver(verificationKeys)
			.setDecryptionKey(decryptionKey.getKey())
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(flowVars.access_token);
return jwtClaims.toJson();]]></scripting:script>
            </scripting:transformer>
        </enricher>
        <enricher source="#[payload.getClaimsMap()]" target="#[flowVars.paymentTokenClaims]" doc:name="var paymentTokenClaims">
            <scripting:transformer doc:name="Extract payment info">
                <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;

JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedAudience('${pisp.expected_audience}')
			.setSkipSignatureVerification()
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(paymentRequestJWS);
return jwtClaims;]]></scripting:script>
            </scripting:transformer>
        </enricher>

        
        <http:request config-ref="banking-accounts-process-api" path="/accounts/aggregate" method="GET" doc:name="get aggregated Accounts">
            <http:request-builder>
                <http:query-param paramName="ssn" value="#[flowVars.accessTokenClaims.ssn]"/>


            </http:request-builder>
        </http:request>
        <dw:transform-message doc:name="Prepare accounts table content">
            <dw:set-payload><![CDATA[%dw 1.0
%output application/java
---
payload map {
	id: $.id,
	label: $.label,
	number: $.number
}]]></dw:set-payload>
        </dw:transform-message>
        <parse-template location="html\accounts.html" doc:name="accounts table"/>

        <logger message="validate payment_token" level="INFO" doc:name="get accounts from pAPI"/>
        <http:request config-ref="banking-accounts-process-api" path="/accounts/aggregate" method="GET" doc:name="get aggregated Accounts">
            <http:request-builder>
                <http:query-param paramName="ssn" value="124-123-12344"/>

            </http:request-builder>
        </http:request>
        <dw:transform-message doc:name="Prepare accounts table html">
            <dw:input-payload doc:sample="sample_data\aggregated_accounts.json"/>
            <dw:set-payload><![CDATA[%dw 1.0
%output application/xml
---
{
	html: {
		head: {
			title: "Anypoint Bank user accounts"
		},
		body: {
			form @(action: "http://localhost:8082/api/payment/account?" ++ flowVars.queryString, method: "post", enctype: "application/x-www-form-urlencoded"): {
				div @(class: "container"): {
					p: "Do you want to make the following payment?",
					p: "Amount: " ++ flowVars.paymentTokenClaims.payment.amount.amount ++ " " ++ flowVars.paymentTokenClaims.payment.amount.curr,
					p: "Receiver: " ++ flowVars.paymentTokenClaims.payment.receiver.name,
					p: "Description: " ++ flowVars.paymentTokenClaims.payment.details.subject,
					table: {
						tr: {
							th: "",
							th: "Account label",
							th: "Account number"
						},
						(payload filter ($.type == "checking") map {
							tr: {
								td: {
									input @(type: "radio", name: "account_id", value: $.id): ""
								},
								td: $.label,
								td: $.number
							}
						}),
						tr: {
							td: "",
							td: "",
							td: {
								button @(type: "submit"): "Select"
							}
						}
					}
				}
			}
		}
	}
}]]></dw:set-payload>
        </dw:transform-message>
        <object-to-string-transformer doc:name="Object to String"/>
        <set-payload value="#[payload.replaceFirst(&quot;&lt;\\?xml.*\\?&gt;&quot;,&quot;&lt;!DOCTYPE html&gt;&quot;)]" doc:name="Replace XML prolog with HTML DOCTYPE"/>
    </flow>

    <flow name="post:/account:api-config">
        <http:listener config-ref="http-continuation" path="/api/payment/account" allowedMethods="POST" doc:name="localhost:8082/api/payment/account"/>
        <logger level="INFO" doc:name="validate access_token" message="POST /account:    #[message.inboundProperties.'http.query.string']"/>
        <set-variable variableName="paymentTokenJWS" value="#[message.inboundProperties.'http.query.params'.request]" doc:name="var paymentTokenJWS"/>
        <logger level="INFO" doc:name="validate payment token"/>
        <set-variable variableName="selectedAcount" value="#[payload.account_id]" doc:name="selectedAccount"/>
        <enricher source="#[payload.getClaimsMap()]" target="#[flowVars.paymentTokenClaims]" doc:name="var paymentTokenClaims">
            <scripting:transformer doc:name="Extract payment info">
                <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;

JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedAudience('${pisp.expected_audience}')
			.setSkipSignatureVerification()
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(flowVars.paymentTokenJWS);
return jwtClaims;]]></scripting:script>
            </scripting:transformer>
        </enricher>
        <logger message="#[flowVars.paymentTokenClaims]" level="INFO" doc:name="Logger"/>
        <dw:transform-message doc:name="prepare request for sAPI">
            <dw:set-payload><![CDATA[%dw 1.0
%output application/json
---
using (paymentInfo = flowVars.paymentTokenClaims.payment)
{
	amount: {
		amount: paymentInfo.amount.amount,
		currency: paymentInfo.amount.curr
	},
	description: paymentInfo.details.subject,
	label: paymentInfo.receiver.name,
	receiver_IBAN: paymentInfo.receiver.IBAN
 }]]></dw:set-payload>
        </dw:transform-message>
        <logger message="#[message.payloadAs(java.lang.String)]" level="INFO" doc:name="Logger"/>
        <http:request config-ref="checking-account-system-api" path="/accounts/{id}/transactions" method="POST" doc:name="Payment">
            <http:request-builder>
                <http:uri-param paramName="id" value="flowVars.selectedAccount"/>
            </http:request-builder>
        </http:request>
        <logger level="INFO" doc:name="show payment outcome"/>
    </flow>

</mule>
