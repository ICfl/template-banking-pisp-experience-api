<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:validation="http://www.mulesoft.org/schema/mule/validation" 
	xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking" 
	xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting"
	xmlns:dw="http://www.mulesoft.org/schema/mule/ee/dw" 
	xmlns="http://www.mulesoft.org/schema/mule/core" 
	xmlns:apikit="http://www.mulesoft.org/schema/mule/apikit" 
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" 
	xmlns:http="http://www.mulesoft.org/schema/mule/http" 
	xmlns:spring="http://www.springframework.org/schema/beans" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/apikit http://www.mulesoft.org/schema/mule/apikit/current/mule-apikit.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
http://www.mulesoft.org/schema/mule/ee/dw http://www.mulesoft.org/schema/mule/ee/dw/current/dw.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/validation http://www.mulesoft.org/schema/mule/validation/current/mule-validation.xsd">
    
    
    <flow name="get:/initiate:api-config">
        <validation:all doc:name="validate query params">
            <validation:validations>
                <validation:is-true expression="#[message.inboundProperties.'http.query.params'.redirect_uri.startsWith(&quot;https&quot;)]" message="Redirect URI must be using HTTPS"/>
                <validation:is-url url="#[message.inboundProperties.'http.query.params'.redirect_uri]" message="Redirect URI must be valid URL"/>
            </validation:validations>
        </validation:all>
        <logger message="#[message.inboundProperties.'http.query.string' ]" level="INFO" doc:name="Log path"/>
        <logger level="INFO" doc:name="Validate client(PISP) &amp; validate JWS"/>
        <set-property propertyName="Location" value="#[  '${as.authorize_url}?' + message.inboundProperties.'http.query.string' ]" doc:name="Location"/>
        <set-property propertyName="http.status" value="302" doc:name="http.status"/>
        <http:request config-ref="auth-server-config" path="/authorize" method="GET" doc:name="Redirect to AS(authorize) for user's login - PISP client_id">
            <http:request-builder>
                <http:query-param paramName="response_type" value="token"/>
                <http:query-param paramName="client_id" value="${pisp.client_id}"/>
                <http:query-param paramName="redirect_uri" value="${pisp.redirect_uri}"/>
            </http:request-builder>
        </http:request>

        <set-payload value="#[NullPayload.getInstance()]" doc:name="Set Null Payload"/>
    </flow>

    
    <flow name="get:/accounts">
        <http:listener config-ref="http-continuation" path="/api/payment/account" allowedMethods="GET" doc:name="localhost:8082/api/payment/account">
         	<http:response-builder>
                <http:header headerName="Content-Type" value="text/html"/>
            </http:response-builder>
         </http:listener>
        <logger message="get:/accounts query: #[message.inboundProperties.'http.query.string']" level="INFO" doc:name="Log request"/>
        <set-variable variableName="queryString" value="#[message.inboundProperties.'http.query.string']" doc:name="save queryString"/>
        <validation:all doc:name="Validate request">
            <validation:validations>
                <validation:is-not-empty value="#[message.inboundProperties.'http.query.params'.request]" message="request cannot be empty"/>
                <validation:is-not-empty value="#[message.inboundProperties.'http.query.params'.redirect_uri]" message="redirect_uri cannot be empty"/>
                <validation:is-not-empty value="#[message.inboundProperties.'http.query.params'.client_id]" message="client_id cannot be empty"/>
            </validation:validations>
        </validation:all>

        <set-variable variableName="access_token" value="#[message.inboundProperties.'http.query.params'.access_token]" doc:name="access_token"/>
        <set-variable variableName="paymentRequestJWS" value="#[message.inboundProperties.'http.query.params'.request]" doc:name="paymentRequestJWS"/>
        <flow-ref name="validateAccessToken" doc:name="validateAccessToken"/>
        <enricher source="#[payload.getClaimsMap()]" target="#[flowVars.paymentTokenClaims]" doc:name="var paymentTokenClaims">
            <scripting:transformer doc:name="Extract payment info">
                <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;

JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedAudience('${pisp.expected_audience}')
			.setSkipSignatureVerification()
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(paymentRequestJWS);
return jwtClaims;]]></scripting:script>
            </scripting:transformer>
        </enricher>


        <http:request config-ref="accounts-process-api" path="/accounts/aggregate" method="GET" doc:name="get aggregated Accounts">
            <http:request-builder>
                <http:query-param paramName="ssn" value="#[flowVars.accessTokenClaims.ssn]"/>



            </http:request-builder>
        </http:request>
        <dw:transform-message doc:name="Prepare accounts table html">
            <dw:input-payload doc:sample="sample_data\aggregated_accounts.json"/>
            <dw:set-payload><![CDATA[%dw 1.0
%output application/xml
---
{
	html: {
		head: {
			title: "Anypoint Bank user accounts"
		},
		body: {
			form @(action: "http://localhost:8082/api/payment/processPayment?" ++ flowVars.queryString, method: "post", enctype: "application/x-www-form-urlencoded"): {
				div @(class: "container"): {
					p: "Do you want to make the following payment?",
					p: "Amount: " ++ flowVars.paymentTokenClaims.payment.amount.amount ++ " " ++ flowVars.paymentTokenClaims.payment.amount.curr,
					p: "Receiver: " ++ flowVars.paymentTokenClaims.payment.receiver.name,
					p: "Description: " ++ flowVars.paymentTokenClaims.payment.details.subject,
					table: {
						tr: {
							th: "",
							th: "Account label",
							th: "Account number"
						},
						(payload filter ($.type == "checking") map {
							tr: {
								td: {
									input @(type: "radio", name: "account_id", value: $.id): ""
								},
								td: $.label,
								td: $.number
							}
						}),
						tr: {
							td: "",
							td: "",
							td: {
								button @(type: "submit"): "Select"
							}
						}
					}
				}
			}
		}
	}
}]]></dw:set-payload>
        </dw:transform-message>
        <object-to-string-transformer doc:name="Object to String"/>
        <set-payload value="#[payload.replaceFirst(&quot;&lt;\\?xml.*\\?&gt;&quot;,&quot;&lt;!DOCTYPE html&gt;&quot;)]" doc:name="Replace XML prolog with HTML DOCTYPE"/>
    </flow>
    <sub-flow name="validateAccessToken">
        <enricher source="#[payload]" target="#[flowVars.decryptionKeyString]" doc:name="var decryptionKeyString">
            <parse-template location="shared-key.jwk" doc:name="load AES key"/>
        </enricher>
        <enricher source="#[payload]" target="#[flowVars.accessTokenClaims]" doc:name="var accessTokenClaims">
            <scripting:transformer returnClass="java.util.Map" doc:name="Validate access_token">
                <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.keys.HmacKey;
import org.jose4j.keys.resolvers.HttpsJwksVerificationKeyResolver;
import org.jose4j.jwk.HttpsJwks;
import org.jose4j.jwk.JsonWebKey;
import org.jose4j.jwk.OctetSequenceJsonWebKey;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;
import org.jose4j.jwa.AlgorithmConstraints;
import org.jose4j.jwa.AlgorithmConstraints.ConstraintType;
import java.security.Key;

decryptionKey = (OctetSequenceJsonWebKey) JsonWebKey.Factory.newJwk(flowVars.decryptionKeyString);

HttpsJwksVerificationKeyResolver verificationKeys = new HttpsJwksVerificationKeyResolver(new HttpsJwks('${as.jwks.url}'));
    
JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setJwsAlgorithmConstraints(new AlgorithmConstraints(ConstraintType.WHITELIST, "RS512"))
			.setJweAlgorithmConstraints(new AlgorithmConstraints(ConstraintType.WHITELIST, "dir"))
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedIssuer('${as.issuer}')
			.setVerificationKeyResolver(verificationKeys)
			.setDecryptionKey(decryptionKey.getKey())
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(flowVars.access_token);
return jwtClaims.getClaimsMap();]]></scripting:script>
            </scripting:transformer>
        </enricher>
    </sub-flow>

    <flow name="post:/processPayment:api-config">
        <http:listener config-ref="http-continuation" path="/api/payment/account" allowedMethods="POST" doc:name="localhost:8082/api/payment/account"/>
        <logger level="INFO" doc:name="log processPayment info" message="POST /processPayment:    #[message.inboundProperties.'http.query.string']"/>
        <set-variable variableName="paymentTokenJWS" value="#[message.inboundProperties.'http.query.params'.request]" doc:name="var paymentTokenJWS"/>

        <set-variable variableName="selectedAccount" value="#[payload.account_id]" doc:name="selectedAccount"/>
        <enricher source="#[payload.getClaimsMap()]" target="#[flowVars.paymentTokenClaims]" doc:name="var paymentTokenClaims">
            <scripting:transformer doc:name="Extract payment info">
                <scripting:script engine="Groovy"><![CDATA[import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;

JwtConsumer jwtConsumer = new JwtConsumerBuilder()
			.setRequireExpirationTime()
			.setMaxFutureValidityInMinutes(30*24*60)
			.setExpectedAudience('${pisp.expected_audience}')
			.setSkipSignatureVerification()
			.build();
		
JwtClaims jwtClaims = jwtConsumer.processToClaims(flowVars.paymentTokenJWS);
return jwtClaims;]]></scripting:script>
            </scripting:transformer>
        </enricher>
        <logger message="Payment token claims : #[flowVars.paymentTokenClaims]" level="INFO" doc:name="Log payment token claims"/>
        <dw:transform-message doc:name="prepare request for sAPI">
            <dw:set-payload><![CDATA[%dw 1.0
%output application/json
---
using (paymentInfo = flowVars.paymentTokenClaims.payment)
{
	amount: {
		amount: paymentInfo.amount.amount,
		currency: paymentInfo.amount.curr
	},
	description: paymentInfo.details.subject,
	label: paymentInfo.receiver.name,
	receiver_IBAN: paymentInfo.receiver.IBAN
 }]]></dw:set-payload>
        </dw:transform-message>
        <logger message="#[message.payloadAs(java.lang.String)]" level="INFO" doc:name="Log request for sAPI"/>
        <http:request config-ref="payments-process-api" path="/accounts/{id}/transactions" method="POST" doc:name="Payment">
            <http:request-builder>
                <http:uri-param paramName="id" value="#[flowVars.selectedAccount]"/>



            </http:request-builder>
        </http:request>
        <logger level="INFO" doc:name="show payment outcome"/>
    </flow>

</mule>
